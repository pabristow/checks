[/ 
Copyright Pierre Talbot 2011.

Use, modification and distribution are subject to the
Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt
or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:algorithm Common check algorithms]

This section will discuss the objectives of the algorithms used in Boost.Checks.
A check algorithm is firstly designed to:

# Catch the most errors as possible that a human (or machine) can make.
# Minimize the cost of the check digit for fast computation.
# Minimize the size (or number) of the check digit(s).

We cannot have our cake and eat it, that's why we often choose
between the size or the efficiency.
Critical numbers, for example, the __IBAN, use two check digits.

The main difference with these algorithms (and the other checksum algorithms 
such as CRC or cryptographic hashes) is that we don't analyse the binary 
content of the sequence but the lexical values meaning, so "123" is equivalent to [~123]. 
It also means we could skip the undesirable values.

[section:checksum_algorithm Checksum algorithms]

Boost.Checks provides only checksum algorithm excepts for the Verhoeff algorithm.

[h5 Trivial digital sum]

The most basic algorithm we could create is to sum every digit in a sequence.
For example the digit sum of [~58215478] is:
``
5 + 8 + 2 + 1 + 5 + 4 + 7 + 8 = 40
``

The check digit would be [~40] so the complete sequence [~5821547840]. The size of
the check digit grown with the sum. 

[h5 Modular sum]

We must restrict the check digit's size so we take the remainder of the sum by a choosen
modulus. This will impact the range of the check digit. For example, the supports 
for 3 types of modulus is implemented in Boost.Checks, the following table points the 
differents modulus:

[table:modulus_range Modulus impact on check digit range
[ [Modulus] [Check digit range] [Check digit size] ]
[ [10] [ 0 to 9 ] [1] ]
[ [11] [ 0 to 10 ] [1] ]
[ [97] [ 0 to 96 ] [2] ]
]

The range of the modulus 11 is restrained to an unique check digit where [~10] is replaced 
by another character (commonly the letter 'X').

[h5 Weighted sum]

The simple sum is a fiasco for detecting transposition errors. The proof is simple: the 
addition is ['commutative], so the digit order is not important. The solution is to 
attribute fixed ['weight] to each position.

The choice of the weight pattern should respect the following statments:

# The weights must be less than the modulus. The explanation is:

``
If weight = modulus, than weight = 0.
And if weight = modulus + 1, than weight = 1.
Finally if weight = modulus + n, than weight = n % modulus.
``

# The weights must be coprime to the modulus. It means the greatest common divisor between 
the weight and the modulus is 1. If a and b are not coprime to the modulus, than 
it exists a number n that verify the following equation:

``
a * n % modulus = b * n % modulus
``

And this number is a common divisor between a,b and the modulus.

# [HS] An error in the checksum is detected if | new_checksum - checksum | != modulus.
# [HS] The assertion: "new_checksum == checksum" doesn't mean that the number is error-free. 
Digits can be compensated or the check digit altered.

The weight pattern is always a limited sequence that can be repetitive. For example: [~137] 
is not repetitive on a sequence with less than 4 numbers but will on a greater sequence. 

The weight pattern greatly depends on the modulus. The weights should be coprime to the modulus, 
we will prove it with an example: 

[table:modulus_influence_on_weight Modulus 10 influence on the weight pattern
[[Position] [1] [2] [3] [4] [5] [6] [7] ]
[[Weight]   [1] [3] [5] [8] [1] [3] [5] ]
[[Number]   [9] [5] [2] [5] [4] [5] [6] ]
]

The weight pattern choose is [~1358] on a seven digits sequence: [~9525456], so the check digit is:

``
check digit = (1*9 + 3*5 + 5*2 + 8*5 + 1*4 + 3*5 + 5*6) % 10
check digit = 3
``

A checksum with weights that are not coprime to 10 could not detect simple alteration. 
For example, we can prove it with the third digit of the sequence above:
``
checksum = 1*9 + 3*5 + 5*X + 8*5 + 1*4 + 3*5 + 5*6
checksum = 113 + 5X


check digit = (113 + 5X) % 10
If X = {0,2,4,6,8}
  check digit = 3
If X = {1,3,5,7,9}
  check digit = 7
``

To avoid this disaster, we should respect the following formula:
``
modulus € 0+ Strict Positive Integer

weight >= 0 AND weight < modulus
d1 >= 0 AND d1 < modulus
d2 >= 0 AND d2 < modulus
d1 != d2

(Weight * d1) % Modulus != (Weight * d2) % Modulus
``

# Note 1: All prime number modulus can be use with any weight.

[table:summary Error catching summary
[[][1 Alteration] [2 Alterations] [Twin transpositions] ]
[[Luhn] [18/18 (100%)] [] [88/90 (97.78%)]]
[[Verhoeff] [18/18 (100%)] [] [90/90 (100%)]]
]

[endsect] [/section:algorithm Common check algorithms]

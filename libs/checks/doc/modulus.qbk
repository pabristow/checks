[section:modulus Modular sum algorithms]

A ['modular sum algorithm] computes the sum of a sequence of digits modulus some number. 
The number obtained is called the ['check digit]; in many codes it is appended as the last digit (or letter).
This simplistic algorithm detects any ['alteration] of one single digit 
but doesn't detect a simple ['transposition] or two (or more) digits if the check digit is not transposed.
This is why even the most basic algorithms introduce the notion of ['weight].
The weight is the contribution of a number to the final sum.
The following algorithms presented are the base of many, many codes and numbers in worldwide use.
We could describe a number and its check digit calculation with three characteristics : length, weight and the modulus. 
So we could design a generic function - but we won't - it wouldn't be efficient and would be unnecessarily complicated.
The next parts will present three different algorithms for which we have choose to design this implementation.

[note We may add other algorithms later.]

[section:luhn Luhn algorithm]

[h5 Description]

The Luhn algorithm is used with a lot of codes and numbers:
the most well-known usage is the verification of the ['credit card numbers]
It produces a check digit from a sequence with an unlimited length.
The weight pattern used is from the rightmost digit (the check digit) doubling the value of every second digit.
It applies a modulus 10 on the sum, so the range of the check digit is from 0 to 9.

[note When a digit is doubled, we subtract 9 from the result if it exceeds 9]

[h5 Errors]

[*Alterations] of any one digit are all caught. The alterations of more than one digit are not all caught.
All [*transpositions] on digits with different weight are caught, but the sequence "90" or "09" is not because: 

[teletype]
``
9*2 = 18 and 18-9 = 9 
9 * 2 = 9 * 1
0 * 2 = 0 * 1
``

The two digits have the same value if they are doubled or not.
Because Luhn alternates a weight of 1 and 2, any transpositions of digits with the same weight are not caught.

[endsect] [/section:luhn Luhn algorithm]

[section:mod10 Modulus 10 algorithm]

[h5 Description]

This algorithm use a modulus 10 as the Luhn algorithm but use a custom weight pattern. 
The sum is made without subtraction if the multiplication of a digit exceeds 9.
The custom weight pattern may be useful for many codes and numbers that aren't implemented in the high level library. 
The user can easily craft his own check function with this weight pattern.

[endsect] [/section:mod10 Modulus 10 algorithm]

[section:mod11 Modulus 11 algorithm]

The modulus 11 algorithm use a modulus of 11, so we have 11 possible check digits. 
The ten first characters are the figures from 0 to 9,
the eleventh is a special character choose by the designer of the number.
It is typically 'X' or 'x'.
The weight of a digit is related to its position.
The weight of the first character is equal to the total length of the number (with the check digit included). 
The weight decreases by one for the second position, one again for the third, etc.

[endsect] [/section:mod11 Modulus 11 algorithm]


[section:summary Summary of Algorithms]

Here a summary of the different algorithms studied.

[table:id Summary of the modular sum algorithms
  [[Algorithm] [Modulus] [Weight pattern] [check digit range]]
  [[Luhn] [10] [... 2 1 2 1] [0..9]]
  [[Modulus 10] [10] [custom] [0..9]]
  [[Modulus 11] [11] [... 2 1 10 ... 4 3 2 1] [0..9 + 'X']]
  [[Modulus 97] [97] [][]]
  [[Verhoeff] [][] []]
]

[endsect] [/section:summary Summary]

[endsect] [/section:modulus Modular sum algorithms]